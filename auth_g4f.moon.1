ffi = require "ffi"
socket = require "socket"
https = require "ssl.https"
ltn12 = require "ltn12"
mime = require "mime"
json = json or require "cjson"
json.encode_escape_forward_slash false if json.encode_escape_forward_slash

local crypto
if ffi.os=="Windows"
  lib = "libcrypto-3"
  lib ..= "x64" if ffi.arch=="x64"
  crypto = ffi.load lib
else
  ok, res = pcall ffi.load, "libcrypto.so.3"
  crypto = res
  unless ok
    ok, res = pcall ffi.load, "libcrypto.3.dylib"
    crypto = res
  unless ok
    error "Could not load OpenSSL 3 library."

ffi.cdef [[
  typedef struct evp_pkey_st EVP_PKEY;
  typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;
  typedef struct bio_st BIO;

  unsigned long ERR_get_error(void);
  void ERR_error_string_n(unsigned long e, char *buf, size_t len);
  // BIO
  BIO *BIO_new_mem_buf(const void *buf, int len);
  int BIO_free(BIO *a);
  // PEM Reading
  EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x, void *cb, void *u);
  void EVP_PKEY_free(EVP_PKEY *pkey);
  // EVP Context
  EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, void *e);
  void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);
  // Encryption
  int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen, const unsigned char *in, size_t inlen);
]]

_assert = (ok, msg, cleanupFn) ->
  unless ok
    err = crypto.ERR_get_error!
    if err!=0
      buf = ffi.new "char[256]"
      crypto.ERR_error_string_n err, buf, 256
      cleanupFn! if cleanupFn
      error "#{msg}: #{ffi.string buf}"

requestBackend = (user) ->
  user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
  response_t = {}
  _, status, _, status_line = assert https.request
    url: 'https://g4f.dev/backend-api/v2/public-key'
    headers: { "User-Agent": user_agent }
    sink: ltn12.sink.table response_t
  assert status==200, status_line

  json_data = assert json.decode table.concat response_t
  json_data.public_key, json.encode
    data: json_data.data
    :user
    timestamp: math.floor socket.gettime! * 1000
    :user_agent
    referrer: "https://g4f.dev/docs/ready_to_use.html"
    provider: "Azure"
    model: "null"

encrypt = (pem_key, data) ->
  bio = crypto.BIO_new_mem_buf pem_key, #pem_key
  _assert bio, "BIO creation failed"

  local pkey, ctx
  safe_cleanup = ->
    crypto.EVP_PKEY_CTX_free ctx if ctx
    crypto.EVP_PKEY_free pkey if pkey

  pkey = crypto.PEM_read_bio_PUBKEY bio, nil, nil, nil
  crypto.BIO_free bio
  _assert pkey, "Failed to parse Public Key"

  ctx = crypto.EVP_PKEY_CTX_new pkey, nil
  _assert ctx, "Context creation failed", safe_cleanup

  _assert crypto.EVP_PKEY_encrypt_init(ctx) > 0,
    "Encrypt Init failed", safe_cleanup

  in_bytes = ffi.cast "const unsigned char*", data
  in_len = #data
  out_len = ffi.new "size_t[1]"

  _assert crypto.EVP_PKEY_encrypt(ctx, nil, out_len, in_bytes, in_len) > 0,
    "Failed to determine output length", safe_cleanup
  out_bytes = ffi.new "unsigned char[?]", out_len[0]

  _assert crypto.EVP_PKEY_encrypt(ctx, out_bytes, out_len, in_bytes, in_len) > 0,
    "Encryption failed", safe_cleanup
  safe_cleanup!
  (mime.b64 ffi.string out_bytes, out_len[0])

main = (user) -> encrypt requestBackend user

return main if ...

print main "test"
