name = "OpenAI-compatible"

local U = ...
if not U.restapi then return end
exe = true

historyName = name

predefined = {
  apibase={
    "https://api.openai.com/v1",
    "https://my-openai-gemini-demo.vercel.app/v1",
    "https://copilot-demo.publicaffairs.workers.dev/v1"
  },
  --https://platform.openai.com/docs/models/overview
  model={"gpt-3.5-turbo", "gpt-4", "gpt-4o", "gpt-4o-mini", "gpt-4-turbo", "gpt-4-turbo-preview"},
  response_format={'{ type="json_object" }'},
  role={"You are a friendly AI assistant"},
}

local function importArgs (args)
  local level = 2
  for i=1,debug.getinfo(level, "u").nparams do
    local name = debug.getlocal(level, i)
    debug.setlocal(level, i, args[name] or args[i])
  end
end

--https://platform.openai.com/docs/api-reference/chat/create#chat-create-messages
return function (session, stream, context, apibase, apikey, model, temperature, role,
                logit_bias, logprobs, top_logprobs, max_tokens, max_completion_tokens, n,
                frequency_penalty, presence_penalty, response_format, seed, stop, top_p, headers)
  local args = type(session)=="table" and session
  if args then importArgs(session) end
  local boolean,number,obj = U.boolean, U.number, U.obj
  local openai = U.restapi.OpenAI
  local client = openai(apikey, apibase, obj(headers))
  local function getMsgText (data)
    local msg = data.message or data.error or data
    msg = msg.error or msg
    return msg.message or msg
  end

  local messages = session and U.getHistory(historyName) or {}
  local data = {
    messages=messages,
    model=model,
    frequency_penalty=number(frequency_penalty),
    logit_bias=obj(logit_bias),
    logprobs=boolean(logprobs),
    top_logprobs=number(top_logprobs),
    max_tokens=number(max_tokens), --deprecated
    max_completion_tokens=number(max_completion_tokens),
    n=number(n),
    presence_penalty=number(presence_penalty),
    response_format=obj(response_format),
    seed=number(seed),
    --service_tier=
    stop=stop,
    stream=boolean(stream),
    --stream_options=
    temperature=number(temperature),
    top_p=number(top_p),

    -- OpenRouter:
    --prompt=
    --repetition_penalty=number(repetition_penalty),
    --transforms=obj(transforms)
    --models=obj(models)
    --route
    --provider
  }
  if role then
    if messages[1] and messages[1].role=="system" then
      messages[1].content = role
    else
      table.insert(messages, 1, {role="system", content=role})
    end
  end
  table.insert(messages, {role="user", content=context})
  if args and args.hook then
    data = args.hook(client,data) or data
  end

  return function (cb)
    local lastIdx, streamed = 0
    local chunks = {}
    local function ln() return chunks[1] and "\n\n" or "" end
    local response,status = client:chat(data, function (chunk,err,extra)
      if err then
        if type(extra)=="string" then err = err.." "..extra end
        return cb(ln().."Error: "..err)
      end
      local candidate = chunk.choices[1]
      if not candidate then return end
      local reason = candidate.finish_reason
      if candidate.index~=lastIdx then
        cb("\n\n")
        lastIdx = candidate.index
      end
      if candidate.delta.content then
        if candidate.index==0 then
          table.insert(chunks, candidate.delta.content)
        end
        cb(candidate.delta.content, chunk.model~=model and chunk.model)
      end
      if reason and reason~="stop" and type(reason)=="string" then
        cb(ln().."finish_reason: "..reason)
      end
      streamed = true
      if U.check"Esc" then error("interrupted", 0) end
    end)
    table.remove(messages) -- readd later on success

    if not response then
      if not streamed then cb("Error: "..status) end
    elseif status==200 then
      if streamed then
        table.insert(messages, {role="user", content=context})
        table.insert(messages, {role="assistant", content=table.concat(chunks)})
      else
        if type(response)=="table" then
          if not response.choices then
            return cb(U.formatJsonMsg(response,getMsgText))
          end
          table.insert(messages, {role="user", content=context})
          table.insert(messages, {role="assistant", content=response.choices[1].message.content})
          for i,candidate in ipairs(response.choices) do
            if i>1 then cb("\n\n") end
            cb(candidate.message.content)
            local reason = candidate.finish_reason
            if reason and reason~="stop" and type(reason)=="string" then
              cb("\nfinish_reason: "..reason)
            end
          end
        else --debug
          far.Message("Unexpected response:\n"..tostring(response), name, nil, "w")
          if type(response)=="string" then
            far.CopyToClipboard(response)
          end
        end
      end
    else -- status~=200
      cb(U.formatErrMsg(response,status,getMsgText))
    end
    cb()
  end
end
