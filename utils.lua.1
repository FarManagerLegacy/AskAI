local Shared = ... -- State, name, cfgpath

local _pathjoin = win.JoinPath or function (...) -- compat shim
  return table.concat({...}, package.config:sub(1,1))
end

local _isWindows = package.config:sub(1,1)=="\\"

local function expandEnv (str) --??linux
  return (str:gsub("%%([%w_]-)%%", win.GetEnv))
end

local function _quote (str)
  return '"'..str..'"'
end

local function _optional (...)
  if select("#", ...)==1 then
    return ... or ""
  end
  local key, value, arg = ...
  if not value then return "" end
  if arg then
    if type(arg)=="function" then
      value = arg(select(4, ...))
    else--if arg~='"' then??
      value = arg:format(value)
    end
  end
  return key.." ".._quote(value)
end

local function readFile (pathname)
  local fp = assert(io.open(pathname, "r"))
  local content = fp:read()
  fp:close()
  return content
end

local function writeFile (pathname, content)
  local fp = assert(io.open(pathname, "w"))
  fp:write(content)
  fp:close()
end

local todel = {}
local function cleanup()
  for _, pathname in ipairs(todel) do
    win.DeleteFile(pathname)
  end
  todel = {}
end

local function _tmpfile (filename, content)
  local pathname = _pathjoin(Shared._tmp, filename)
  writeFile(pathname, content)
  table.insert(todel, pathname)
  return '"'..pathname..'"'
end

local function check (key)
  repeat
    local k = win.ExtractKeyEx()
    if k and far.InputRecordToName(k)==key then return true end
  until not k
end

local function _pipeOut (exe, context)
  return function (args)
    args[0] = _quote(exe)
    local cmd = table.concat(args, " ", 0)
    if context then -- env
      cmd = (_isWindows and "type %s|" or "cat %s|"):format(_tmpfile("file.input", context))..cmd
    end
    return function (cb)
      local pipe = io.popen(_quote(cmd).." 2>&1", "r")
      repeat
        if check"Esc" then break end
        local chunk = pipe:read(5)
        if not chunk then break end
        while not chunk:isvalid() do --ensure valid utf-8
          local extra = pipe:read(1)
          if extra then chunk = chunk..extra; else break; end
        end
        cb(chunk)
      until false
      cb()
      pipe:close()
      cleanup()
    end
  end
end

if pcall(require, "piper") then
  local STILL_ACTIVE = 259
  local _shell = win.GetEnv"ComSpec".." /c"
  function _pipeOut (exe, context)
    return function (args)
      args[0] = _quote(exe)
      local cmd = table.concat(args, " ", 0)
      return function (cb)
        local prc = require"piper"(_shell.._quote(cmd), {input=context})
        if not prc then return end
        if prc.ExitCode==STILL_ACTIVE or prc.ExitCode==0 then
          for chunk in prc.utf8chunks do
            if check"Esc" then break end
            cb(chunk)
          end
          cb()
        else -- debug
          far.Message("ExitCode: "..prc.ExitCode.."\n\1\n"..prc.all:gsub("\r\n","\n"), Shared.name, nil, "wl")
        end
        cleanup()
      end
    end
  end
end

local function _import (filename, env, ...)
  local pathname = _pathjoin(Shared.cfgpath,filename)
  local fn = assert(loadfile(pathname))
  env = env or getfenv(2) -- parent _ENV
  local name = env.name
  local ret = setfenv(fn,env)(Shared, ...)
  if name and name~=env.name then
    env.name = ("%s [%s]"):format(name, env.name)
  end
  return ret, env
end

local function isReachable (fname, source)
  if type(fname)=="boolean" then return fname end
  local _type = type(fname)
  if _type~="string" then
    far.Message("exe: string or boolean expected, got ".._type, source, nil, "w")
    return
  end
  for ext in win.GetEnv("PATHEXT"):gmatch"%.[^;]+" do
    --https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-searchpathw
    local filename = win.SearchPath(nil,fname,ext)
    if filename then
      return not win.GetFileAttr(filename):find"d"
    end
  end
end

local mt = setmetatable({
  _import=_import,
  _isWindows=_isWindows,
  _optional=_optional,
  _pathjoin=_pathjoin,
  _pipeOut=_pipeOut,
  _quote=_quote,
  _tmpfile=_tmpfile,
}, { __index=_G })
local function loadCfg (pathname)
  local env = setmetatable({}, { __index=mt })
  local fn = assert(loadfile(pathname))
  local applyParamsFn = setfenv(fn, env)(Shared)
  for _,param in ipairs{"config", "sessionFile"} do
    if env[param] then
      env[param] = expandEnv(env[param])
    end
  end
  return {
    applyParamsFn = applyParamsFn,
    info = env,
    pathname = pathname,
    reachable = isReachable(env.exe, pathname)
  }
end

local function clearSession (info, session)
  if info.clearSession then
    if type(info.clearSession)=="function" then
      info.clearSession(session)
    else
      local cmd = info.clearSession:format(session)
      win.system(cmd)
    end
  elseif info.sessionFile then
    local pathname = info.sessionFile:format(session)
    win.DeleteFile(pathname)
  end
end

local function HelpTopic (name)
  return ("<%s\\>%s"):format(Shared.cfgpath, name)
end

local HK = {
  iter=function(self,skip)
    if skip then return self.spc end
    self.i = self.i+1
    local _hk = self.i==10 and "0" or self.i<10 and self.i or string.char(self.i + string.byte"a" - 11)
    _hk = "&".._hk
    return _hk..self.fmt
  end,
}
local _hkmt = { __index=HK }
function HK.new (fmt)
  return setmetatable({ i=0, fmt=fmt, spc=string.rep(" ",fmt:len()+1) }, _hkmt)
end

return {
  readFile=readFile,
  writeFile=writeFile,
  loadCfg=loadCfg,
  clearSession=clearSession,
  HelpTopic=HelpTopic,
  HK=HK,
}
